import React, { useState, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Textarea } from '@/components/ui/textarea';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Plus, Shield, Clock, Users, DollarSign, Info, Loader, RefreshCw, Edit } from 'lucide-react';
import { useToast } from '@/hooks/use-toast';
import { useContractInstances } from '@/provider/ContractInstanceProvider';
import { ethers } from 'ethers';
import { Saving_ABI } from '@/lib/ABI/Saving_ABI';
import tokens from '@/lib/Tokens/tokens';

const CreateGroup = () => {
  const { toast } = useToast();
  const { SAVING_CONTRACT_INSTANCE, TEST_TOKEN_CONTRACT_INSTANCE,    MULTICURRENCY_SAVING_CONTRACT_INSTANCE } = useContractInstances();

  // Token options for the group - using valid testnet addresses
  const getSupportedTokens = () => {
    return tokens.filter(token => token.id > 1);
  };

const [formData, setFormData] = useState({
  groupName: '',
  description: '',
  contributionAmount: '',
  frequency: '',
  maxMembers: '',
  tokenType: getSupportedTokens()[0]?.address || '', // Use address instead of symbol
  duration: ''
});

  const [inviteCode, setInviteCode] = useState('');
  const [inviteCodeGenerationFailed, setInviteCodeGenerationFailed] = useState(false);
  const [groupIdForManualGeneration, setGroupIdForManualGeneration] = useState('');
  const [isGeneratingInviteCode, setIsGeneratingInviteCode] = useState(false);

  const [isCreating, setIsCreating] = useState(false);

  // Debug useEffect to monitor state changes
  useEffect(() => {
    console.log('State changed - inviteCodeGenerationFailed:', inviteCodeGenerationFailed);
    console.log('State changed - groupIdForManualGeneration:', groupIdForManualGeneration);
  }, [inviteCodeGenerationFailed, groupIdForManualGeneration]);

  // Frequency options in seconds (matching smart contract)
  const frequencyOptions = [
    { value: '300', label: '5 minutes', seconds: 300 },
    { value: '86400', label: 'Daily', seconds: 86400 },
    { value: '604800', label: 'Weekly', seconds: 604800 },
    { value: '1209600', label: 'Bi-weekly', seconds: 1209600 },
    { value: '2592000', label: 'Monthly', seconds: 2592000 },
  ];



  // Convert token amount to Wei
  const toWei = (amount: string, decimals = 18) => {
    if (!amount) return '0';
    const multiplier = Math.pow(10, decimals);
    return (parseFloat(amount) * multiplier).toString();
  };

  // Note: Invite codes are now generated by the smart contract
  // This function is kept for reference but not used
  const generateInviteCode = (groupName: string, contributionAmount: string, maxMembers: string) => {
    const timestamp = Date.now().toString(36).toUpperCase();
    const groupHash = btoa(groupName + contributionAmount + maxMembers).slice(0, 8).toUpperCase();
    return `${groupHash}-${timestamp}`;
  };

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();

  if (
    !formData.groupName ||
    !formData.contributionAmount ||
    !formData.frequency ||
    !formData.maxMembers ||
    !formData.tokenType
  ) {
    toast({
      title: "Missing Information",
      description: "Please fill in all required fields including token selection.",
      variant: "destructive",
    });
    return;
  }

  setIsCreating(true);

  try {
    console.log("Form data:", formData);

    const Saving_Contract = await SAVING_CONTRACT_INSTANCE();
    if (!Saving_Contract) {
      throw new Error("Smart contract not initialized");
    }

    console.log("Smart contract instance:", Saving_Contract);
    console.log("Contract address:", await Saving_Contract.getAddress());

    // Convert values to proper format
    const contributionInWei = toWei(formData.contributionAmount);
    const frequencySeconds = parseInt(formData.frequency);
    const maxMembers = parseInt(formData.maxMembers);

    console.log("Converted values:", {
      contributionInWei,
      frequencySeconds,
      maxMembers,
    });

    // Get the selected token address
    const selectedToken = getSupportedTokens().find(
      (t) => t.address === formData.tokenType
    );
    if (!selectedToken) {
      toast({
        title: "Token Error",
        description: "Please select a valid token",
        variant: "destructive",
      });
      return;
    }

    const tokenAddress = selectedToken.address;
    console.log("Selected token:", selectedToken, "Address:", tokenAddress);

    if (!tokenAddress || !tokenAddress.startsWith("0x") || tokenAddress.length !== 42) {
      throw new Error(`Invalid token address: ${tokenAddress}`);
    }
    if (!/^0x[a-fA-F0-9]{40}$/.test(tokenAddress)) {
      throw new Error(`Invalid token address format: ${tokenAddress}`);
    }
    if (tokenAddress === "0x0000000000000000000000000000000000000000") {
      console.log("Using zero address for Naira token");
    }

    // Create group on smart contract
    console.log("Creating group with params:", {
      name: formData.groupName,
      description: formData.description || `${formData.groupName} - A savings group`,
      tokenAddress,
      contributionInWei,
      frequencySeconds,
      maxMembers,
    });

    let tx;
    try {
      tx = await Saving_Contract.createGroup(
        formData.groupName,
        formData.description || `${formData.groupName} - A savings group`,
        tokenAddress,
        contributionInWei,
        frequencySeconds,
        maxMembers
      );
      console.log("Transaction created successfully:", tx);
    } catch (contractError) {
      console.error("Smart contract call failed:", contractError);
      throw new Error(
        `Smart contract error: ${contractError.message || contractError}`
      );
    }

    toast({
      title: "Creating Group... ðŸ”„",
      description: "Processing your request on the blockchain.",
      duration: 2000,
    });

    // Wait for the group creation transaction to be mined
    const receipt = await tx.wait();
    console.log("Group creation transaction receipt:", receipt);

    // Success toast
    toast({
      title: "Group Created Successfully! ðŸŽ‰",
      description: `${formData.groupName} has been created successfully.`,
      duration: 5000,
    });

    // Reset form but keep default token
    setFormData({
      groupName: "",
      description: "",
      contributionAmount: "",
      frequency: "",
      maxMembers: "",
      tokenType: getSupportedTokens()[0]?.address || "",
      duration: "",
    });
  } catch (error) {
    console.error("Error creating group:", error);

    let errorMessage =
      "Failed to create group. Please check your wallet and try again.";
    if (error instanceof Error) {
      errorMessage = error.message;
    } else if (typeof error === "string") {
      errorMessage = error;
    }

    toast({
      title: "Creation Failed",
      description: errorMessage,
      variant: "destructive",
      duration: 5000,
    });
  } finally {
    setIsCreating(false);
  }
};

const handleSave = async () => {
  try {
    const Saving_Contract = await MULTICURRENCY_SAVING_CONTRACT_INSTANCE();
    if (!Saving_Contract) {
      throw new Error("Smart contract not initialized");
    }

    const wrapperAddress = "0xa9976e9812e680a81c49Dd1D28b9ED88222c9d4e"; // Replace with actual wrapper address

    // Send tx
    const tx = await Saving_Contract.addTrustedContract(wrapperAddress);

    console.log("Transaction sent:", tx.hash);

    // Wait for confirmation
    const receipt = await tx.wait();
    console.log("Transaction confirmed:", receipt);

    alert("Wrapper contract added successfully âœ…");
  } catch (error) {
    console.error("Error adding trusted contract:", error);
    alert(`Failed to add trusted contract: ${error.message}`);
  }
};
  const handleInputChange = (field: string, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  const handleManualInviteCodeGeneration = async () => {
    if (!groupIdForManualGeneration) {
      toast({
        title: "Group ID Required",
        description: "Please create a group first to get the group ID.",
        variant: "destructive",
      });
      return;
    }

    setIsGeneratingInviteCode(true);
    
    try {
      const Saving_Contract = await SAVING_CONTRACT_INSTANCE();
      if (!Saving_Contract) {
        throw new Error('Smart contract not initialized');
      }

      console.log('Manually generating invite code for group:', groupIdForManualGeneration);
      
      // First, validate that the group exists and user is authorized
      try {
        const groupInfo = await Saving_Contract.getGroupInfo(groupIdForManualGeneration);
        console.log('Group info retrieved:', groupInfo);
        
        // Check if group exists and is not active
        if (!groupInfo || groupInfo.isActive) {
          throw new Error('Group not found or already active');
        }
        
        // Check if user is the creator (optional validation)
        try {
          // ethers.js v6: getSigner is on the provider, but Saving_Contract.runner?.provider may not be a Signer-capable provider.
          // Instead, use window.ethereum if available, or however the app gets the user's signer.
          let userAddress: string | undefined;
          if (window.ethereum) {
            const provider = new ethers.BrowserProvider(window.ethereum);
            const signer = await provider.getSigner();
            userAddress = await signer.getAddress();
          } else {
            // fallback: try to get from Saving_Contract.runner if possible
            const provider: any = Saving_Contract.runner?.provider;
            if (provider && typeof provider.getSigner === 'function') {
              const signer = provider.getSigner();
              userAddress = await signer.getAddress();
            }
          }
          if (userAddress && groupInfo.creator && userAddress.toLowerCase() !== groupInfo.creator.toLowerCase()) {
            console.warn('User is not the group creator, but proceeding with invite code generation');
          }
        } catch (addressError) {
          console.log('Could not get user address for validation:', addressError);
        }
      } catch (validationError) {
        console.error('Group validation failed:', validationError);
        // Continue anyway as the contract might handle this
      }
      
      // Generate invite code with better error handling
      console.log('Calling generateInviteCode with params:', {
        groupId: groupIdForManualGeneration,
        maxUses: 10,
        validityDays: 30
      });
      
      const inviteCodeTx = await Saving_Contract.generateInviteCode(
        groupIdForManualGeneration,
        10, // maxUses
        30  // validityDays
      );
      
      console.log('Manual invite code generation transaction:', inviteCodeTx);
      console.log('Transaction hash:', inviteCodeTx.hash);
      
      // Wait for the transaction with timeout
      const inviteCodeReceipt = await Promise.race([
        inviteCodeTx.wait(),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Transaction timeout')), 60000)
        )
      ]);
      
      console.log('Manual invite code generation receipt:', inviteCodeReceipt);
      
      // Extract the invite code from the event logs with improved parsing
      let generatedInviteCode = '';
      const iface = new ethers.Interface(Saving_ABI);
      
      console.log('Parsing transaction logs...');
      console.log('Number of logs:', inviteCodeReceipt.logs.length);
      
      for (let i = 0; i < inviteCodeReceipt.logs.length; i++) {
        const log = inviteCodeReceipt.logs[i];
        console.log(`Log ${i}:`, log);
        
        try {
          const parsedLog = iface.parseLog(log);
          console.log(`Parsed log ${i}:`, parsedLog.name, parsedLog.args);
          
          if (parsedLog.name === 'InviteCodeGenerated') {
            generatedInviteCode = parsedLog.args.code;
            console.log('âœ… Found invite code in event logs:', generatedInviteCode);
            break;
          }
        } catch (parseError) {
          console.log(`Could not parse log ${i}:`, parseError);
          // Try alternative parsing methods
          try {
            // Check if it's a raw event log
            if (log.topics && log.topics.length > 0) {
              const eventSignature = log.topics[0];
              console.log(`Event signature: ${eventSignature}`);
              
              // Check if this matches InviteCodeGenerated event
              try {
                const decodedData = iface.decodeEventLog('InviteCodeGenerated', log.data, log.topics);
                generatedInviteCode = decodedData.code;
                console.log('âœ… Decoded invite code from raw log:', generatedInviteCode);
                break;
              } catch (decodeError) {
                console.log('Could not decode event log:', decodeError);
              }
            }
          } catch (altParseError) {
            console.log(`Alternative parsing also failed for log ${i}:`, altParseError);
          }
        }
      }
      
      if (generatedInviteCode) {
        setInviteCode(generatedInviteCode);
        setInviteCodeGenerationFailed(false);
        setGroupIdForManualGeneration(''); // Clear the manual generation state
        
        toast({
          title: "Invite Code Generated! ðŸŽ‰",
          description: `Your invite code has been successfully generated: ${generatedInviteCode}`,
          duration: 8000,
        });
        
        // Refresh the page or update state as needed
        console.log('âœ… Manual invite code generation completed successfully');
      } else {
        // Try to get the invite code from the contract directly
        console.log('Attempting to get invite code from contract directly...');
        try {
          const groupInviteCode = await Saving_Contract.groupInviteCode(groupIdForManualGeneration);
          console.log('Group invite code from contract:', groupInviteCode);
          
          if (groupInviteCode && groupInviteCode !== "0" && groupInviteCode !== "") {
            setInviteCode(groupInviteCode);
            setInviteCodeGenerationFailed(false);
            setGroupIdForManualGeneration('');
            
            toast({
              title: "Invite Code Retrieved! ðŸŽ‰",
              description: `Your invite code: ${groupInviteCode}`,
              duration: 8000,
            });
            return;
          }
        } catch (directCallError) {
          console.log('Direct contract call failed:', directCallError);
        }
        
        // If all else fails, show detailed error
        console.error('Could not extract invite code from any source');
        throw new Error('Invite code generation succeeded but could not be retrieved. Please check the transaction hash and contact support.');
      }
      
    } catch (error) {
      console.error('Error manually generating invite code:', error);
      
      let errorMessage = "Failed to generate invite code. ";
      
      if (error instanceof Error) {
        if (error.message.includes('Group not found')) {
          errorMessage += "The group does not exist or is already active.";
        } else if (error.message.includes('Not the group creator')) {
          errorMessage += "Only the group creator can generate invite codes.";
        } else if (error.message.includes('Group already active')) {
          errorMessage += "Cannot generate invite codes for active groups.";
        } else if (error.message.includes('Transaction timeout')) {
          errorMessage += "Transaction took too long. Please check your wallet and try again.";
        } else if (error.message.includes('insufficient funds')) {
          errorMessage += "Insufficient funds for gas fees.";
        } else if (error.message.includes('user rejected')) {
          errorMessage += "Transaction was rejected by user.";
        } else {
          errorMessage += error.message;
        }
      } else if (typeof error === 'string') {
        errorMessage += error;
      } else {
        errorMessage += "Please check your wallet and try again.";
      }
      
      toast({
        title: "Manual Generation Failed",
        description: errorMessage,
        variant: "destructive",
        duration: 8000,
      });
      
      // Keep the manual generation state active for retry
      console.log('Manual generation failed, keeping state for retry');
    } finally {
      setIsGeneratingInviteCode(false);
    }
  };

  return (
    <div className="max-w-6xl mx-auto">


      <div className="grid grid-cols-1 xl:grid-cols-4 gap-8">
        {/* Main Form */}
        <form onSubmit={handleSubmit} className="xl:col-span-3 space-y-8">
          {/* Group Identity Card */}
          <Card className="border border-gray-200 bg-gradient-to-br from-white to-gray-50/50 shadow-lg">
            <CardHeader className="pb-6">
              <div className="flex items-center gap-3">
                <div className="w-12 h-12 bg-gradient-to-br from-primary/20 to-primary/10 rounded-xl flex items-center justify-center">
                  <Plus className="h-6 w-6 text-primary" />
                </div>
                <div>
                  <CardTitle className="text-2xl font-bold">Group Identity</CardTitle>
                  <p className="text-muted-foreground">Define your group's purpose and character</p>
                </div>
              </div>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div className="space-y-3">
                  <Label htmlFor="groupName" className="text-sm font-semibold text-foreground">
                    Group Name *
                  </Label>
                  <Input
                    id="groupName"
                    placeholder="e.g., Lagos Tech Professionals"
                    value={formData.groupName}
                    onChange={(e) => handleInputChange('groupName', e.target.value)}
                    required
                    className="h-12 text-base border border-gray-200 focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white"
                  />
                </div>
                <div className="space-y-3">
                  <Label htmlFor="maxMembers" className="text-sm font-semibold text-foreground">
                    Max Members *
                  </Label>
                  <Select value={formData.maxMembers} onValueChange={(value) => handleInputChange('maxMembers', value)} required>
                    <SelectTrigger className="h-12 text-base border border-gray-200 focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white">
                      <SelectValue placeholder="Select group size" />
                    </SelectTrigger>
                    <SelectContent>
                      {Array.from({ length: 19 }, (_, i) => i + 2).map(num => (
                        <SelectItem key={num} value={num.toString()}>{num} members</SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
              
              <div className="space-y-3">
                <Label htmlFor="description" className="text-sm font-semibold text-foreground">
                  Description
                </Label>
                <Textarea
                  id="description"
                  placeholder="Brief description of your group's purpose and members"
                  value={formData.description}
                  onChange={(e) => handleInputChange('description', e.target.value)}
                  rows={3}
                  className="text-base border-2 border-gray-200 focus:border-primary focus:ring-4 focus:ring-primary/10 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white"
                />
              </div>
            </CardContent>
          </Card>

          {/* Financial Terms Card */}
          <Card className="border border-gray-200 bg-gradient-to-br from-white to-gray-50/50 shadow-lg">
            <CardHeader className="pb-6">
              <div className="flex items-center gap-3">
                <div className="w-12 h-12 bg-gradient-to-br from-success/20 to-success/10 rounded-xl flex items-center justify-center">
                  <DollarSign className="h-6 w-6 text-success" />
                </div>
                <div>
                  <CardTitle className="text-2xl font-bold">Financial Terms</CardTitle>
                  <p className="text-muted-foreground">Set contribution amounts and frequency</p>
                </div>
              </div>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div className="space-y-3">
                  <Label htmlFor="contributionAmount" className="text-sm font-semibold text-foreground">
                    Contribution Amount *
                  </Label>
                  <div className="relative">
                    <DollarSign className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                    <Input
                      id="contributionAmount"
                      type="number"
                      placeholder="25000"
                      className="pl-10 h-12 text-base border border-gray-200 focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white"
                      value={formData.contributionAmount}
                      onChange={(e) => handleInputChange('contributionAmount', e.target.value)}
                      required
                    />
                  </div>
                </div>
                
                <div className="space-y-3">
                  <Label htmlFor="frequency" className="text-sm font-semibold text-foreground">
                    Payment Frequency *
                  </Label>
                  <Select value={formData.frequency} onValueChange={(value) => handleInputChange('frequency', value)} required>
                    <SelectTrigger className="h-12 text-base border border-gray-200 focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white">
                      <SelectValue placeholder="How often?" />
                    </SelectTrigger>
                    <SelectContent>
                      {frequencyOptions.map((option) => (
                        <SelectItem key={option.value} value={option.value}>
                          {option.label}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Token Selection Card */}
          <Card className="border border-gray-200 bg-gradient-to-br from-white to-gray-50/50 shadow-lg">
            <CardHeader className="pb-6">
              <div className="flex items-center gap-3">
                <div className="w-12 h-12 bg-gradient-to-br from-blue-500/20 to-blue-500/10 rounded-xl flex items-center justify-center">
                  <div className="w-6 h-6 bg-blue-500 rounded-full flex items-center justify-center">
                    <span className="text-white text-xs font-bold">â‚¿</span>
                  </div>
                </div>
                <div>
                  <CardTitle className="text-2xl font-bold">Preferred Token</CardTitle>
                  <p className="text-muted-foreground">Choose the token for contributions and payouts</p>
                </div>
              </div>
            </CardHeader>
            <CardContent className="space-y-6">
            <div className="space-y-3">
  <Label htmlFor="tokenType" className="text-sm font-semibold text-foreground">
    Select Token *
  </Label>
  <Select value={formData.tokenType} onValueChange={(value) => handleInputChange('tokenType', value)} required>
    <SelectTrigger className="h-12 text-base border border-gray-200 focus:border-primary focus:ring-2 focus:ring-primary/20 transition-all duration-300 bg-white/80 backdrop-blur-sm hover:bg-white">
      <SelectValue placeholder="Choose your preferred token" />
    </SelectTrigger>
    <SelectContent>
      {getSupportedTokens().map((token) => (
        <SelectItem key={token.id} value={token.address}>
          <div className="flex items-center gap-2">
            <span className="font-medium">{token.name}</span>
            <Badge variant="outline" className="text-xs">
              {token.symbol}
            </Badge>
          </div>
        </SelectItem>
      ))}
    </SelectContent>
  </Select>
  
  {/* Token Information */}
  {formData.tokenType && (
    <div className="p-4 bg-gray-50 rounded-lg border border-gray-200">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium text-gray-700">Selected Token:</span>
          <Badge variant="secondary" className="bg-blue-100 text-blue-700">
            {getSupportedTokens().find(t => t.address === formData.tokenType)?.name}
          </Badge>
        </div>
        <span className="text-xs text-gray-500">
          {getSupportedTokens().find(t => t.address === formData.tokenType)?.symbol}
        </span>
      </div>
      <p className="text-xs text-gray-600 mt-2">
        All contributions and payouts will be processed in this token
      </p>
    </div>
  )}
</div>
            </CardContent>
          </Card>

          <Button onClick={handleSave}>SAVE WRAPPER</Button>

          {/* Submit Button */}
          <Button 
            type="submit" 
            disabled={isCreating}
            className="w-auto px-8 h-12 text-base bg-gradient-to-r from-primary to-primary/80 shadow-sm hover:shadow-sm rounded-lg transition-all duration-300"
          >
            {isCreating ? (
              <>
                <Loader className="h-5 w-5 mr-2 animate-spin" />
                Creating Group...
              </>
            ) : (
              <>
                <Shield className="h-5 w-5 mr-2" />
                Create Secure ROSCA Group
              </>
            )}
          </Button>
        </form>
        
        {/* Info Sidebar */}
        <div className="space-y-6">
          {/* Smart Contract Info */}
          <Card className="border-0 bg-white/60 backdrop-blur-sm shadow-sm hover:shadow-md transition-all duration-300">
            <CardHeader className="pb-4">
              <CardTitle className="flex items-center gap-3 text-base font-semibold text-gray-800">
                <div className="w-8 h-8 bg-primary/10 rounded-lg flex items-center justify-center">
                  <Shield className="h-4 w-4 text-primary" />
                </div>
                Smart Contract Security
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="flex items-start gap-3 p-3 bg-gray-50/50 rounded-lg">
                <div className="w-1.5 h-1.5 rounded-full bg-primary mt-2 flex-shrink-0" />
                <div>
                  <p className="font-medium text-sm text-gray-800">Automated Collections</p>
                  <p className="text-xs text-gray-600 mt-1">No manual handling of funds</p>
                </div>
              </div>
              <div className="flex items-start gap-3 p-3 bg-gray-50/50 rounded-lg">
                <div className="w-1.5 h-1.5 rounded-full bg-primary mt-2 flex-shrink-0" />
                <div>
                  <p className="font-medium text-sm text-gray-800">Transparent Payouts</p>
                  <p className="text-xs text-gray-600 mt-1">All transactions on blockchain</p>
                </div>
              </div>
              <div className="flex items-start gap-3 p-3 bg-gray-50/50 rounded-lg">
                <div className="w-1.5 h-1.5 rounded-full bg-primary mt-2 flex-shrink-0" />
                <div>
                  <p className="font-medium text-sm text-gray-800">Dispute Resolution</p>
                  <p className="text-xs text-gray-600 mt-1">Built-in arbitration system</p>
                </div>
              </div>
            </CardContent>
          </Card>

          {/* Preview */}
         {formData.contributionAmount && formData.maxMembers && (
  <Card className="border-0 bg-white/60 backdrop-blur-sm shadow-sm hover:shadow-md transition-all duration-300">
    <CardHeader className="pb-4">
      <CardTitle className="flex items-center gap-3 text-base font-semibold text-gray-800">
        <div className="w-8 h-8 bg-green-100 rounded-lg flex items-center justify-center">
          <Info className="h-4 w-4 text-green-600" />
        </div>
        Group Preview
      </CardTitle>
    </CardHeader>
    <CardContent className="space-y-4">
      <div className="flex justify-between items-center p-3 bg-gray-50/50 rounded-lg">
        <span className="text-sm text-gray-600">Total Pool</span>
        <Badge variant="secondary" className="bg-primary/10 text-primary text-xs">
          {getSupportedTokens().find(t => t.address === formData.tokenType)?.symbol || ''}{(parseInt(formData.contributionAmount) * parseInt(formData.maxMembers)).toLocaleString()}
        </Badge>
      </div>
      <div className="flex justify-between items-center p-3 bg-gray-50/50 rounded-lg">
        <span className="text-sm text-gray-600">Payout Amount</span>
        <span className="font-semibold text-gray-800">
          {getSupportedTokens().find(t => t.address === formData.tokenType)?.symbol || ''}{parseInt(formData.contributionAmount)?.toLocaleString()}
        </span>
      </div>
      <div className="flex justify-between items-center p-3 bg-gray-50/50 rounded-lg">
        <span className="text-sm text-gray-600">Token</span>
        <Badge variant="outline" className="bg-blue-100 text-blue-700 text-xs">
          {getSupportedTokens().find(t => t.address === formData.tokenType)?.name || ''}
        </Badge>
      </div>
      <div className="flex justify-between items-center p-3 bg-gray-50/50 rounded-lg">
        <span className="text-sm text-gray-600">Duration</span>
        <span className="font-semibold text-gray-800">{formData.maxMembers} rounds</span>
      </div>
    </CardContent>
  </Card>
)}


          {/* Cultural Context */}
          <Card className="border-0 bg-white/60 backdrop-blur-sm shadow-sm hover:shadow-md transition-all duration-300">
            <CardHeader className="pb-4">
              <CardTitle className="flex items-center gap-3 text-base font-semibold text-gray-800">
                <div className="w-8 h-8 bg-amber-100 rounded-lg flex items-center justify-center">
                  <Users className="h-4 w-4 text-amber-600" />
                </div>
                Cultural Heritage
              </CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-sm text-gray-600 leading-relaxed">
                Ajo/Esusu has been building African communities for centuries. 
                BondFi preserves this tradition while adding modern security and global accessibility.
              </p>
            </CardContent>
          </Card>
        </div>
      </div>
    </div>
  );
};

export default CreateGroup;
